<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI í€´ì¦ˆ ìƒì„±ê¸°</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- JSZip for PPTX parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <!-- PDF.js for PDF parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>

    <style>
        @import url('https://cdn.jsdelivr.net/gh/webfontworld/gmarket/GmarketSans.css');

        body {
            font-family: 'GmarketSans', sans-serif;
            background-color: #ffffff;
        }

        .quiz-card {
            background-color: #f8f9fa;
            transition: all 0.3s ease;
        }

        .quiz-card:hover {
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }

        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3b82f6;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="text-gray-800 h-screen flex flex-col md:flex-row overflow-hidden">

    <!-- Sidebar -->
    <aside class="w-full md:w-80 bg-gray-50 border-r border-gray-200 p-6 flex flex-col h-auto md:h-full overflow-y-auto z-10 shadow-md md:shadow-none">
        <div class="mb-8">
            <h1 class="text-2xl font-bold text-blue-600 mb-2">ğŸ“ AI í€´ì¦ˆ ìƒì„±ê¸°</h1>
            <p class="text-sm text-gray-500">ìˆ˜ì—… ìë£Œë¥¼ ì—…ë¡œë“œí•˜ë©´ Geminiê°€ í€´ì¦ˆë¥¼ ë§Œë“¤ì–´ì¤ë‹ˆë‹¤.</p>
        </div>

        <div class="space-y-6">
            <!-- API Key Input Section -->
            <div class="bg-blue-50 p-4 rounded-xl border border-blue-100">
                <label class="block text-sm font-bold text-gray-700 mb-2">Gemini API Key</label>
                
                <input type="password" id="apiKey" placeholder="AIza... (ì—¬ê¸°ì— ë¶™ì—¬ë„£ê¸°)" 
                    class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all text-sm mb-2 bg-white">
                
                <div class="flex gap-2">
                    <button onclick="saveApiKey()" class="flex-1 bg-blue-600 text-white text-xs py-2 rounded-lg font-bold hover:bg-blue-700 transition-colors shadow-sm">
                        ğŸ’¾ í‚¤ ì €ì¥
                    </button>
                    <button onclick="deleteApiKey()" class="flex-1 bg-white text-red-500 border border-red-200 text-xs py-2 rounded-lg font-bold hover:bg-red-50 transition-colors">
                        ğŸ—‘ï¸ ì‚­ì œ
                    </button>
                </div>
                
                <p id="keyStatusMsg" class="text-xs mt-2 font-bold h-4"></p>
                
                <p class="text-xs text-gray-400 mt-2 leading-relaxed">
                    * <a href="https://aistudio.google.com/app/apikey" target="_blank" class="text-blue-600 underline font-bold">Google AI Studio</a> í‚¤ í•„ìˆ˜<br>
                    (âš ï¸ Cloud Vertex AI í‚¤ ì‘ë™ ë¶ˆê°€)
                </p>
            </div>

            <hr class="border-gray-200">

            <!-- File Upload -->
            <div>
                <label class="block text-sm font-medium text-gray-700 mb-1">í•™ìŠµ ìë£Œ ì—…ë¡œë“œ</label>
                <div class="relative border-2 border-dashed border-gray-300 rounded-lg p-6 hover:bg-gray-100 transition-colors text-center cursor-pointer" onclick="document.getElementById('fileInput').click()">
                    <input type="file" id="fileInput" accept=".pdf,.pptx,.txt" class="hidden" onchange="handleFileSelect(event)">
                    <div id="fileLabel">
                        <span class="text-2xl block mb-2">ğŸ“‚</span>
                        <span class="text-sm text-gray-500">í´ë¦­í•˜ì—¬ íŒŒì¼ ì„ íƒ<br>(PDF, PPTX, TXT)</span>
                    </div>
                </div>
                <p id="fileNameDisplay" class="text-sm text-blue-600 mt-2 font-medium hidden truncate"></p>
            </div>

            <!-- Generate Button -->
            <button id="generateBtn" onclick="startGeneration()" disabled
                class="w-full bg-blue-600 text-white py-3 rounded-lg font-bold hover:bg-blue-700 disabled:bg-gray-300 disabled:cursor-not-allowed transition-colors shadow-sm flex justify-center items-center gap-2">
                ğŸš€ í€´ì¦ˆ ìƒì„±í•˜ê¸°
            </button>

             <!-- CSV Download Button (Hidden initially) -->
             <button id="downloadBtn" onclick="downloadCSV()" class="hidden w-full bg-green-600 text-white py-3 rounded-lg font-bold hover:bg-green-700 transition-colors shadow-sm flex justify-center items-center gap-2 mt-4">
                ğŸ’¾ CSV ë‹¤ìš´ë¡œë“œ
            </button>
        </div>

        <div class="mt-auto pt-6 text-xs text-gray-400 text-center">
            Made with HTML5 & Gemini
        </div>
    </aside>

    <!-- Main Content -->
    <main class="flex-1 bg-white p-4 md:p-8 overflow-y-auto h-full relative">
        
        <!-- Welcome Message / Empty State -->
        <div id="emptyState" class="h-full flex flex-col items-center justify-center text-gray-400">
            <div class="text-6xl mb-4">ğŸ‘‹</div>
            <p class="text-lg text-center">
                ì™¼ìª½ íŒŒë€ ìƒìì— <b>API Key</b>ë¥¼ ì €ì¥í•˜ê³ <br>
                íŒŒì¼ì„ ì˜¬ë ¤ì£¼ì„¸ìš”.
            </p>
        </div>

        <!-- Loading Indicator -->
        <div id="loadingIndicator" class="hidden absolute inset-0 bg-white/90 z-20 flex flex-col items-center justify-center">
            <div class="loader mb-4"></div>
            <p class="text-lg font-bold text-gray-700 mb-1" id="loadingText">ì²˜ë¦¬ ì¤‘...</p>
            <p class="text-sm text-gray-500" id="loadingSubText">ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”</p>
        </div>

        <!-- Quiz Container -->
        <div id="quizContainer" class="max-w-4xl mx-auto space-y-6 pb-20 hidden">
            <div class="flex items-center justify-between mb-6">
                <h2 class="text-2xl font-bold text-gray-800">ğŸ§© ìƒì„±ëœ í€´ì¦ˆ</h2>
                <span id="quizCountBadge" class="bg-blue-100 text-blue-800 text-sm font-medium px-3 py-1 rounded-full">0 ë¬¸ì œ</span>
            </div>
            
            <div id="quizList" class="space-y-6">
                <!-- Quizzes will be injected here -->
            </div>
        </div>

    </main>

    <!-- Scripts -->
    <script>
        // State
        let currentFile = null;
        let extractedText = "";
        let quizzes = [];

        // UI Helpers
        const getEl = (id) => document.getElementById(id);
        const setStatus = (msg, color = "text-blue-600") => {
            const el = getEl('keyStatusMsg');
            el.textContent = msg;
            el.className = `text-xs mt-2 font-bold h-4 ${color}`;
        };

        // --- API Key Management ---
        window.onload = function() {
            const savedKey = localStorage.getItem('gemini_api_key');
            if (savedKey) {
                getEl('apiKey').value = savedKey;
                setStatus("âœ… ì €ì¥ëœ í‚¤ ë¡œë“œ ì™„ë£Œ", "text-green-600");
                checkReady();
            }
        };

        function saveApiKey() {
            const key = getEl('apiKey').value.trim();
            if (!key) return alert("API í‚¤ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.");
            
            // Basic Validation Warning (Not blocking, just warning)
            if (!key.startsWith("AIza")) {
                alert("ì•Œë¦¼: í‚¤ í˜•ì‹ì´ ì¼ë°˜ì ì´ì§€ ì•ŠìŠµë‹ˆë‹¤. ê·¸ë˜ë„ ì €ì¥ì„ ì§„í–‰í•©ë‹ˆë‹¤.");
            }

            localStorage.setItem('gemini_api_key', key);
            setStatus("ğŸ’¾ ë¸Œë¼ìš°ì €ì— í‚¤ ì €ì¥ë¨!", "text-blue-600");
            setTimeout(() => setStatus(""), 3000);
            checkReady();
        }

        function deleteApiKey() {
            localStorage.removeItem('gemini_api_key');
            getEl('apiKey').value = "";
            checkReady();
            setStatus("ğŸ—‘ï¸ í‚¤ ì‚­ì œë¨", "text-red-500");
            setTimeout(() => setStatus(""), 3000);
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            currentFile = file;
            getEl('fileNameDisplay').textContent = `ì„ íƒë¨: ${file.name}`;
            getEl('fileNameDisplay').classList.remove('hidden');
            getEl('fileLabel').innerHTML = '<span class="text-green-500 font-bold">âœ“ íŒŒì¼ ì¤€ë¹„ ì™„ë£Œ</span>';
            
            checkReady();
        }

        getEl('apiKey').addEventListener('input', checkReady);

        function checkReady() {
            const apiKey = getEl('apiKey').value.trim();
            const btn = getEl('generateBtn');
            btn.disabled = !(apiKey && currentFile);
        }

        // ----------------------------------------------------------------
        // Text Extraction Logic
        // ----------------------------------------------------------------
        async function extractText() {
            if (!currentFile) return null;
            const fileType = currentFile.name.split('.').pop().toLowerCase();
            
            try {
                if (fileType === 'txt') return await currentFile.text();
                if (fileType === 'pdf') return await extractPdf(currentFile);
                if (fileType === 'pptx') return await extractPptx(currentFile);
                throw new Error("ì§€ì›í•˜ì§€ ì•ŠëŠ” íŒŒì¼ í˜•ì‹");
            } catch (error) {
                throw new Error(`í…ìŠ¤íŠ¸ ì¶”ì¶œ ì‹¤íŒ¨: ${error.message}`);
            }
        }

        async function extractPdf(file) {
            const arrayBuffer = await file.arrayBuffer();
            const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
            let fullText = "";
            for (let i = 1; i <= pdf.numPages; i++) {
                const page = await pdf.getPage(i);
                const textContent = await page.getTextContent();
                fullText += textContent.items.map(item => item.str).join(' ') + "\n";
            }
            return fullText;
        }

        async function extractPptx(file) {
            const zip = await JSZip.loadAsync(file);
            let fullText = "";
            const slideFiles = Object.keys(zip.files)
                .filter(name => name.startsWith('ppt/slides/slide') && name.endsWith('.xml'))
                .sort((a, b) => {
                    const numA = parseInt(a.match(/slide(\d+)\.xml/)[1]);
                    const numB = parseInt(b.match(/slide(\d+)\.xml/)[1]);
                    return numA - numB;
                });

            for (const filename of slideFiles) {
                const content = await zip.file(filename).async("string");
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(content, "text/xml");
                const textNodes = xmlDoc.getElementsByTagName("a:t");
                for(let i=0; i<textNodes.length; i++) fullText += textNodes[i].textContent + " ";
                fullText += "\n";
            }
            return fullText;
        }

        // ----------------------------------------------------------------
        // Gemini API Logic (Multi-Model Fallback)
        // ----------------------------------------------------------------
        async function callGemini(prompt, isJsonArray = true) {
            const apiKey = getEl('apiKey').value.trim();
            
            // Fallback strategy: Try latest models first, then stable/older ones.
            const models = ['gemini-1.5-flash', 'gemini-1.5-pro', 'gemini-1.0-pro'];
            
            let lastError = null;

            for (const model of models) {
                try {
                    updateLoadingText(`AI ëª¨ë¸(${model}) ì—°ê²° ì¤‘...`, "ìµœì ì˜ ì‘ë‹µì„ ì°¾ëŠ” ì¤‘ì…ë‹ˆë‹¤");
                    // Pass isJsonArray to handle parsing correctly per model
                    return await fetchGemini(model, apiKey, prompt, isJsonArray);
                } catch (e) {
                    console.warn(`Model ${model} failed:`, e);
                    lastError = e;
                    
                    // If it's 404, it means model not found/access denied -> Try next.
                    // If it's 5xx, server error -> Try next.
                    // If it's 400 (Bad Request), it MIGHT be config issue, so try next (especially for 1.0-pro which doesn't support JSON mode).
                }
            }
            
            // If all failed
            throw lastError;
        }

        async function fetchGemini(modelName, apiKey, prompt, isJsonArray) {
            const url = `https://generativelanguage.googleapis.com/v1beta/models/${modelName}:generateContent?key=${apiKey}`;
            
            const payload = {
                contents: [{ parts: [{ text: prompt }] }],
                safetySettings: [
                    { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" },
                    { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" },
                    { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_NONE" },
                    { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_NONE" }
                ]
            };

            // Only use JSON mode for 1.5 models (1.0-pro doesn't support responseMimeType)
            if (modelName.includes('1.5')) {
                payload.generationConfig = { responseMimeType: "application/json" };
            }

            const response = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                let msg = `Error ${response.status}`;
                try {
                    const err = await response.json();
                    if(err.error) msg += `: ${err.error.message}`;
                } catch(e){}
                throw new Error(msg);
            }

            const data = await response.json();
            
            if (!data.candidates || !data.candidates[0] || !data.candidates[0].content) {
                throw new Error("AI ì‘ë‹µì´ ë¹„ì–´ìˆìŠµë‹ˆë‹¤.");
            }

            const text = data.candidates[0].content.parts[0].text;
            
            // Parse logic
            try {
                // 1. Try direct parse (for JSON mode)
                return JSON.parse(text);
            } catch (e) {
                // 2. Fallback for Markdown blocks (```json ... ```)
                let clean = text.replace(/```json/g, '').replace(/```/g, '').trim();
                try {
                    return JSON.parse(clean);
                } catch (e2) {
                    // 3. Last resort: Find [ ... ] or { ... }
                    const start = isJsonArray ? text.indexOf('[') : text.indexOf('{');
                    const end = isJsonArray ? text.lastIndexOf(']') : text.lastIndexOf('}');
                    if (start !== -1 && end !== -1) {
                        return JSON.parse(text.substring(start, end + 1));
                    }
                    throw new Error("AI ì‘ë‹µì„ JSONìœ¼ë¡œ ë³€í™˜í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.");
                }
            }
        }

        // ----------------------------------------------------------------
        // App Logic
        // ----------------------------------------------------------------
        function updateLoadingText(main, sub) {
            getEl('loadingText').textContent = main;
            getEl('loadingSubText').textContent = sub || "";
        }

        async function startGeneration() {
            const loading = getEl('loadingIndicator');
            loading.classList.remove('hidden');
            
            try {
                updateLoadingText("ë¬¸ì„œ ì½ëŠ” ì¤‘...", "í…ìŠ¤íŠ¸ë¥¼ ì¶”ì¶œí•˜ê³  ìˆìŠµë‹ˆë‹¤");
                if (!extractedText || extractedText.length < 10) {
                    extractedText = await extractText();
                }

                if (!extractedText) throw new Error("í…ìŠ¤íŠ¸ë¥¼ ì¶”ì¶œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");

                // Prompt optimized for all models
                const prompt = `
                Role: Education Expert.
                Task: Create 5 multiple-choice questions (4 options each) in Korean based on the context.
                
                IMPORTANT OUTPUT FORMAT:
                Return ONLY a raw JSON Array. Do not use Markdown code blocks.
                [
                    {
                        "question": "ë¬¸ì œ",
                        "options": ["ë³´ê¸°1", "ë³´ê¸°2", "ë³´ê¸°3", "ë³´ê¸°4"],
                        "answer": "ì •ë‹µ(ë³´ê¸°ì™€ ë™ì¼)",
                        "explanation": "í•´ì„¤"
                    }
                ]

                [Context]
                ${extractedText.substring(0, 20000)}
                `;

                quizzes = await callGemini(prompt, true);
                
                renderQuizzes();
                getEl('emptyState').classList.add('hidden');
                getEl('quizContainer').classList.remove('hidden');
                getEl('downloadBtn').classList.remove('hidden');

            } catch (error) {
                alert(`ì˜¤ë¥˜ ë°œìƒ (ëª¨ë“  ëª¨ë¸ ì‹œë„ ì‹¤íŒ¨):\n${error.message}`);
            } finally {
                loading.classList.add('hidden');
            }
        }

        async function regenerateQuestion(index) {
            const card = document.getElementById(`quiz-card-${index}`);
            const originalHTML = card.innerHTML;
            
            card.innerHTML = `<div class="py-10 text-center"><div class="loader inline-block mb-2"></div><p class="text-sm text-gray-500">ìƒˆë¡œìš´ ë¬¸ì œ ìƒì„± ì¤‘...</p></div>`;

            try {
                const prompt = `
                Create 1 multiple-choice question in Korean based on the context.
                
                OUTPUT FORMAT:
                Return ONLY a single raw JSON Object.
                {
                    "question": "ë¬¸ì œ",
                    "options": ["ë³´ê¸°1", "ë³´ê¸°2", "ë³´ê¸°3", "ë³´ê¸°4"],
                    "answer": "ì •ë‹µ",
                    "explanation": "í•´ì„¤"
                }
                
                [Context]
                ${extractedText.substring(0, 5000)}
                `;

                const newQuiz = await callGemini(prompt, false);
                quizzes[index] = newQuiz;
                renderQuizzes();

            } catch (error) {
                alert(`ì¬ìƒì„± ì‹¤íŒ¨: ${error.message}`);
                card.innerHTML = originalHTML; 
            }
        }

        function deleteQuestion(index) {
            if(confirm("ì •ë§ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) {
                quizzes.splice(index, 1);
                renderQuizzes();
            }
        }

        function renderQuizzes() {
            const container = getEl('quizList');
            getEl('quizCountBadge').textContent = `${quizzes.length} ë¬¸ì œ`;
            
            container.innerHTML = quizzes.map((q, idx) => `
                <div id="quiz-card-${idx}" class="quiz-card bg-white p-6 rounded-xl border border-gray-200">
                    <div class="flex justify-between items-start mb-4">
                        <h3 class="text-lg font-bold text-gray-900 flex-1 pr-4">Q${idx + 1}. ${q.question}</h3>
                        <div class="flex gap-2">
                            <button onclick="regenerateQuestion(${idx})" class="text-blue-500 hover:text-blue-700 p-1" title="ì¬ìƒì„±">ğŸ”„</button>
                            <button onclick="deleteQuestion(${idx})" class="text-red-500 hover:text-red-700 p-1" title="ì‚­ì œ">ğŸ—‘ï¸</button>
                        </div>
                    </div>
                    <div class="space-y-2 mb-4">
                        ${q.options.map((opt, i) => `
                            <div class="flex items-center p-3 rounded-lg border border-gray-100 bg-white hover:bg-gray-50">
                                <span class="w-6 h-6 flex items-center justify-center rounded-full bg-gray-100 text-xs font-bold mr-3 text-gray-500">${i+1}</span>
                                <span class="text-gray-700">${opt}</span>
                            </div>
                        `).join('')}
                    </div>
                    <details class="group">
                        <summary class="flex cursor-pointer items-center gap-2 text-sm font-medium text-blue-600 hover:text-blue-800 select-none">
                            <span>ğŸ’¡ ì •ë‹µ ë° í•´ì„¤</span>
                            <span class="transition group-open:rotate-180">â–¼</span>
                        </summary>
                        <div class="mt-3 rounded-lg bg-green-50 p-4 text-sm text-green-800 border border-green-100">
                            <p class="font-bold mb-1">ì •ë‹µ: ${q.answer}</p>
                            <p>${q.explanation}</p>
                        </div>
                    </details>
                </div>
            `).join('');
        }

        function downloadCSV() {
            if (quizzes.length === 0) return;
            const BOM = "\uFEFF";
            let csvContent = BOM + "ë²ˆí˜¸,ë¬¸ì œ,ë³´ê¸°1,ë³´ê¸°2,ë³´ê¸°3,ë³´ê¸°4,ì •ë‹µ,í•´ì„¤\n";
            quizzes.forEach((q, index) => {
                const safe = (str) => `"${(str || '').toString().replace(/"/g, '""')}"`;
                csvContent += [
                    index + 1, safe(q.question), safe(q.options[0]), safe(q.options[1]),
                    safe(q.options[2]), safe(q.options[3]), safe(q.answer), safe(q.explanation)
                ].join(",") + "\n";
            });
            const link = document.createElement("a");
            link.href = URL.createObjectURL(new Blob([csvContent], { type: 'text/csv;charset=utf-8;' }));
            link.download = "generated_quiz.csv";
            link.click();
        }
    </script>
</body>
</html>
